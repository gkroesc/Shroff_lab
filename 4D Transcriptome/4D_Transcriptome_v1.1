
from PIL import Image, ImageDraw, ImageFont
import pandas as pd
import os
import shutil
import timeit
import random
import datetime
import pathlib
import math


class CellClass():
	def __init__(self, name, coord_path, tpm_path, lineage, genes):

		self.name = name
		self.lineage = lineage
		self.coord_path = coord_path
		self.coords = dict()
		self.coord_data = pd.read_csv(self.coord_path, index_col = False, header=None)
		# self.color = list()
		# self.assoc = list()
		self.coords["x"] = list()
		self.coords["y"] = list()
		self.coords["z"] = list()
		self.TPM_means, self.TPM_loess  = self.setTPMFrames(tpm_path, genes)

	def setCoords(self):
		for i in range(len(self.coord_data)):
			self.coords["x"].append(self.coord_data.iat[i,1])
			self.coords["y"].append(self.coord_data.iat[i,2])
			self.coords["z"].append(self.coord_data.iat[i,3])

	def setTPMFrames(self, tpm_path, genes):

		means_frames = list()
		loess_frames = list()

		for gene in genes:
			df = pd.read_csv('{}/{}/{}.csv'.format(tpm_path, gene, self.name))
			df['gene'] = gene
			temp_m = df.loc[df['data.type'] == 'means']
			temp_l = df.loc[df['data.type'] == 'loess']

			#temp_l = temp_l.loc[temp_l['x'] >= 420] #cutoff at 420
			#Filling early timepoints
			fill_early = list(range(0, temp_l['x'].min()))
			fill_e_df = pd.DataFrame(data = {'x': fill_early, 'gene':gene, 'data.type': 'loess'})

			fill_late = list(range(temp_l['x'].max()+1, 900))
			fill_l_df = pd.DataFrame(data = {'x': fill_late, 'gene':gene, 'data.type': 'loess'})


			temp_l = pd.concat([fill_e_df, temp_l, fill_l_df])
			temp_l = temp_l.loc[temp_l['x'] >= 420]
			temp_l = temp_l.loc[temp_l['x'] <= 840]


			means_frames.append(temp_m)
			loess_frames.append(temp_l)


		means_df = pd.concat(means_frames)
		loess_df = pd.concat(loess_frames)
		loess_df['norm_loess_by_gene'] = 0
		return(means_df, loess_df)

	def setColor(self, n): #N passed as argument in main when called.

		for i in self.TPM_loess['norm_loess_by_gene'].to_list():

			intensity = int(norm_tpm * (255*3))

			if intensity > 255*2:
				rgb = ((255*3)-intensity, 0, 0)
			elif intensity > 255:
				pass
				rgb = (255,(255*2)-intensity, 0)
			else:
				#less than 255
				rgb = (255,255,255-intensity)
		self.color.append(rgb)

class SeamCellClass():
	def __init__(self, name, coord_path, lineage):

		self.name = name
		self.lineage = lineage
		self.coord_path = coord_path
		self.coords = dict()
		self.coord_data = pd.read_csv(self.coord_path, index_col = False, header=None)
	# 	self.color = list()
	# 	self.assoc = list()
		self.coords["x"] = list()
		self.coords["y"] = list()
		self.coords["z"] = list()
	#
	#
	# #### Setters ####
	def setCoords(self):
		for i in range(len(self.coord_data)):
			self.coords["x"].append(self.coord_data.iat[i,1])
			self.coords["y"].append(self.coord_data.iat[i,2])
			self.coords["z"].append(self.coord_data.iat[i,3])


def main():
	genes = getGenes(['vab-1', 'vab-2'])
	model_cell_dir = "data/model_cell_coords"
	GSE_cell = pd.read_csv("data/GSE126954/GSE126954_cell_annotation.csv")
	GSE_gene = pd.read_csv("data/GSE126954/GSE126954_gene_annotation.csv")
	masterkey = pd.read_csv("cell keys/masterkey.csv")
	gene_output_dir = "output/{}".format(datetime.date.today())
	outputsuff = '_'.join(str(e) for e in genes)
	outputdir = gene_output_dir+'/'+outputsuff+'_visualization'
	cells, seamCells = loadCells(model_cell_dir, masterkey, gene_output_dir, outputdir, genes)
	#
	normalize(genes, cells)
	print(cells[random.randint(0, len(cells))].TPM_loess.to_string())
	print(timeit.default_timer())

def finalColor(cells, seamCells):
	pass

def normalize(genes, cells):
	for gene in genes:
		maxgene = list()
		for cell in cells:
			maxgene.append(cell.TPM_loess.loc[cell.TPM_loess['gene'] == gene]['y'].max())

		maxgene = max(maxgene)
		# print('maxmax', maxgene)
		for cell in cells:
			mask = (cell.TPM_loess['gene'] == gene)
			matching_cells = cell.TPM_loess[mask]

			cell.TPM_loess.loc[mask, 'norm_loess_by_gene'] = matching_cells['y'] / maxgene


			###USE DICTIONARY INSTEAD SO YOU CAN APPLY FUNCTION ALONG THE WHOLE DF WITHOUT FOR LOOP.
			### REF DICTIONARY TO GET MAX AND USE Y as lambda x: x/dict[y_gene]
		#minimum is 0 99.999999999% of the time.

def filter(genes, cells):
	final_cells = list()
	missing_ls = list()
	for cell in cells:
		ct = len(genes)
		for gene in genes:
			gframe = cell.TPM_loess.loc[cell.TPM_loess['gene'] == gene]
			if len(cell.TPM_means[cell.TPM_means['gene'] == gene]) < 20:
				missing_ls.append('{}'.format(cell.name))
				ct -= 1
				break
			elif gframe['se'].max() > cell.TPM_means.loc[cell.TPM_means['gene'] == gene]['y'].max():
				missing_ls.append('{}'.format(cell.name))
				ct -= 1
				break
		if len(genes) == ct:
			final_cells.append(cell)
	print("Following cells {} will be dropped due to insufficient data: \n{}".format(int(len(missing_ls)), '\n'.join(missing_ls)))

	return(final_cells)

def getGenes(genein = None):
	if genein == None:
		print("Enter gene name(s) below separated by commas.\nEx: 'par-1, par-2, par-3' ")

		genein = input("\nGenes: ").lower().replace(" ", "")
		genesls = genein.strip().split(',')

		return(genesls)
	else:
		return(genein)

def loadCells(model_cell_dir, masterkey, gene_output_dir, outputdir, genes):

	sc = [
			"H0L", "H1L", "H2L", "V1L", "V2L", "V3L", "V4L", "QL", "V5L", "V6L", "TL",
			"H0R", "H1R", "H2R", "V1R", "V2R", "V3R", "V4R", "QR", "V5R", "V6R", "TR"
		 ]

	model_cell_names = masterkey['model cellname'].unique()

	cells = list()
	seamCells = list()
	missing_ls = list()
	final_model_cell_ls = list()

	for name in model_cell_names:
		ct = 0
		for gene in genes:
			path = "{}/{}/{}.csv".format(gene_output_dir, gene, name)
			if os.path.exists(path) == False:
				missing_ls.append("{}".format(name))
				ct += 1
				break

		if ct == 0:
			final_model_cell_ls.append(name)

	print("Following cells {} will be dropped due to insufficient data: \n{}".format(int(len(missing_ls)), '\n'.join(missing_ls)))


	for cellname in final_model_cell_ls:
		wa_lin = masterkey[masterkey['model cellname'] == cellname]['wormatlas lineage'].to_list()
		wa_lin = wa_lin[0]
		coord_path = model_cell_dir+'/{}.csv'.format(cellname)


		if cellname in model_cell_names:
			cells.append(CellClass(name = cellname, coord_path = coord_path, tpm_path = gene_output_dir, lineage = wa_lin, genes = genes))
		elif cellname in sc:
			seamCells.append(SeamCellClass(name = cellname, coord_path = coord_path, lineage = wa_lin))
		else:
			print("{} did not load properly. ".format(cellname))

	return cells, seamCells


main()

class CellClass():
	def __init__(self, name, coord_path, tpm_path, lineage, genes):

		self.name = name
		self.tpm_path = tpm_path
		self.lineage = lineage
		self.coord_path = coord_path
		self.coords = dict()
		self.coord_data = pd.read_csv(self.coord_path, index_col = False, header=None)
		self.color = list()
		self.assoc = list()
		self.coords["x"] = list()
		self.coords["y"] = list()
		self.coords["z"] = list()
		self.TPM_means_Frame, self.TPM_loess_Frame  = self.setTPMFrame(genes)

	#### Setters ####
	def setCoords(self):
		for i in range(len(self.coord_data)):
			self.coords["x"].append(self.coord_data.iat[i,1])
			self.coords["y"].append(self.coord_data.iat[i,2])
			self.coords["z"].append(self.coord_data.iat[i,3])

	def setTPMFrame(self, genes):

		ls = list()
		for gene in genes:
			tpm_df = pd.read_csv("{}/{}/{}.csv".format(self.tpm_path, gene, self.name))
			tpm_df.insert(1,'Gene', gene)
			ls.append(tpm_df)
		temp = pd.concat(ls, ignore_index=True)

		meansdf = temp.loc[temp['data.type'] == 'means']
		loessdf = temp.loc[temp['data.type'] == 'loess']

		return(meansdf, loessdf)


class SeamCellClass():
	def __init__(self, name, coord_path, lineage):

		self.name = name
		self.lineage = lineage
		self.coord_path = coord_path
		self.coords = dict()
		self.coord_data = pd.read_csv(self.coord_path, index_col = False, header=None)
		self.color = list()
		self.assoc = list()
		self.coords["x"] = list()
		self.coords["y"] = list()
		self.coords["z"] = list()


	#### Setters ####
	def setCoords(self):
		for i in range(len(self.coord_data)):
			self.coords["x"].append(self.coord_data.iat[i,1])
			self.coords["y"].append(self.coord_data.iat[i,2])
			self.coords["z"].append(self.coord_data.iat[i,3])


def main():

	genes = getGenes()

	### Directories ###
	model_cell_dir = "data/model_cell_coords"
	GSE_cell = pd.read_csv("data/GSE126954/GSE126954_cell_annotation.csv")
	GSE_gene = pd.read_csv("data/GSE126954/GSE126954_gene_annotation.csv")
	gene_output_dir = "output/{}".format(datetime.date.today())
	outputsuff = '_'.join(str(e) for e in genes)
	outputdir = gene_output_dir+'/'+outputsuff+'_visualization'
	pathlib.Path(outputdir).mkdir(parents=True, exist_ok=True)
	###

	masterkey = pd.read_csv("cell keys/masterkey.csv")

	cells, seamCells = loadCells(model_cell_dir, masterkey, gene_output_dir, outputdir, genes)

	cells, maxTPM, minTPM = getMinMaxTPM(genes, cells)

	normGeneTPM(cells, genes, minTPM, maxTPM)

	for cell in cells: 
		print(cell.TPM_loess_Frame['norm_tpm'].max())

def loadCells(model_cell_dir, masterkey, gene_output_dir, outputdir, genes):

	sc = [
			"H0L", "H1L", "H2L", "V1L", "V2L", "V3L", "V4L", "QL", "V5L", "V6L", "TL",
			"H0R", "H1R", "H2R", "V1R", "V2R", "V3R", "V4R", "QR", "V5R", "V6R", "TR"
		 ]

	model_cell_names = masterkey['model cellname'].unique()

	cells = list()
	seamCells = list()

	for cellname in model_cell_names:
		wa_lin = masterkey[masterkey['model cellname'] == cellname]['wormatlas lineage'].to_list()
		wa_lin = wa_lin[0]
		coord_path = model_cell_dir+'/{}.csv'.format(cellname)

		paths = list()
		for gene in genes: 
			if os.path.exists("{}/{}/{}.csv".format(gene_output_dir, gene, cellname)):
				paths.append("{}/{}/{}.csv".format(gene_output_dir, gene, cellname))

		if len(paths) != len(genes): 
			print("{} dropped because there are not enough points to apply loess".format(cellname))
			continue
		if cellname in sc:
			print('-->'+cellname)
			seamCells.append(SeamCellClass(name = cellname, coord_path = coord_path, lineage = wa_lin))
		elif cellname in model_cell_names:
			cells.append(CellClass(name = cellname, coord_path = coord_path, tpm_path = gene_output_dir, lineage = wa_lin, genes = genes))
		else:
			noAnnls += 1	

# def loadCells(model_cell_dir, masterkey, tpm_path):
# 	#Check 6/14/22
# 	'''
# 	input: directory for cells in model, masterkey, path for calculated TPM (from R)
# 	purpose: initiate classes for each cell. seam cells and tracked cells.
# 	output: list of seam cells and list of cells. Each cell can be called by indexing the list and using class operators
# 	'''
# 	sc = ["H0L", "H1L", "H2L", "V1L", "V2L", "V3L", "V4L", "QL", "V5L", "V6L", "TL",
# 			"H0R", "H1R", "H2R", "V1R", "V2R", "V3R", "V4R", "QR", "V5R", "V6R", "TR"]

# 	model_cell_names = masterkey['model cellname'].unique()

# 	cells = []
# 	seamCells = []
# 	#getting coords
# 	for cellname in model_cell_names:
# 		wa_lin = masterkey[masterkey['model cellname'] == cellname]['wormatlas lineage'].to_list()
# 		wa_lin = wa_lin[0]
# 		coord_path = model_cell_dir+'/{}.csv'.format(cellname)


# 		if cellname in sc:
# 			seamCells.append(SeamCellClass(name = cellname, coord_path = coord_path, tpm_path = tpm_path, lineage = wa_lin))
# 		elif cellname in model_cell_names:
# 			cells.append(CellClass(name = cellname, coord_path = coord_path, tpm_path = tpm_path, lineage = wa_lin))
# 		else:
# 			noAnnls += 1

# 	return cells, seamCells

def getGenes():

	print("Enter gene name(s) below separated by commas.\nEx: 'par-1, par-2, par-3' ")

	genein = input("\nGenes: ").lower().replace(" ", "")
	genesls = genein.strip().split(',')

	return(genesls)

def normGeneTPM(cells, genes, minmin, maxmax):
	#takes df from cell class instance and generates normalized values where 
	#expression at given timepoint is normalized by the min/max of that gene 
	#across all cells and all timepoints
	#norm_func <- function(x, xmin, xmax) {((x - xmin) / (xmax - xmin))}

	for i in range(len(genes)):
		for cell in cells:
			raw_y = cell.TPM_loess_Frame['y'].to_list()

			cell.TPM_loess_Frame['norm_tpm'] = [( (y - minmin[i]) / (maxmax[i] - minmin[i]) ) for y in raw_y]

def getMinMaxTPM(genes, cells):
	#Get the minimum and maximum TPM across all cells across all time
	maxmax = list()
	minmin = list()
	cellListFinal = list()
	for gene in genes:
		maxs = list()
		mins = list()

		for cell in cells:
			tempdf = cell.TPMFrame
			tempdf = tempdf.loc[tempdf['type' == 'loess']]
			tempdf = tempdf.loc[tempdf['Gene' == gene]]
			

			if cell.TPM_loess_Frame['se'].max() > cell.TPM_means_Frame['y'].max():
				#if se of loess curve is greater than the maximum value for the means, then drop the cell. 
				print("Dropping {} because standard error in loess is too high".format(cell))
				continue

			elif length(TPM_means_Frame['y']) < 15:
				print("Dropping {} because there are not enough points to apply loess".format(cell))
				continue

			else:
				tmax = tempdf['y'].max() 
				tmin = tempdf['y'].min()
				cellListFinal.append(cell)

		maxmax.append(maxs.max())
		minmin.append(mins.min())

		return(cellListFinal, maxmax, minmin)


main()